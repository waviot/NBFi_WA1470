# WAVIoT Embedded RnD Code Style

## Общие понятия
Данный документ предназначен для описания единообразного стиля программирования в рамках отдела RnD на языке Си.
Документ применим для оформления исходного кода встраиваемого ПО.
Книга Макконнелла «Совершенный код» (Steve McConnell — «Code Complete»).

## Файлы с исходным кодом
Файлы должны быть в кодировке UTF-8. Каждый `*.c`/`*.h` файл должен начинаться заголовка, который должен содержать:

Шаблон заголовка:

    /*!
     * \file {name}.c
     * \date 10-July-2018
     * \project {project}
     * \copyright WAVIoT
     * \author {name} {lastname} <author1@WAVIoT.ru>, 2020
     * \author {name} {lastname} <author2@WAVIoT.ru>, 2017-2019
     */

`project {project}` указывается в main.c файле и других файлах, жестко привязанных к конкретному проекту.

Ascii графика - моветон.

Каждый файл должен заканчиваться новой пустой строкой.

## Общие правила кодирования

Использовать только необходимые подключаемые файлы. В исходниках подключать только те header файлы, которые используются в данном исходном файле. Если подключаемый файл необходим и в `*.c`, и  `*.h`, то `#include ` нужно разместить в `*.h` файле, а в `*.c` подключить соответствующий `*.h` файл.

Например:

module.c

    #include "module.h"

    void Foo(bool arg)
    {}

module.h

    #include <stdbool.h>

    void Foo(bool arg);

Функция не должна иметь слишком большое количество параметров (не более 7). Параметры следует упорядочивать по степени их важности либо порядку их использования внутри функции. Не используйте входные параметры в качестве рабочих переменных. Если функция не имеет входных параметров, обязательно прописать в параметрах void.

Минимизация области видимости переменной:

- Располагать команды использующие одну и туже переменную как можно ближе друг к другу.
- Инициализировать переменные непосредственно перед их использованием

Использовать каждую переменную только с одной целью. 
Важно! Инициализировать переменные значением по умолчанию.

## Стилистика кода

Именование глобальных переменных и функций выполняется CamelCase: `SensorMeasurementTime`. Именование локальных переменных и функций выполняется lowerCamelCase: `totalMeasTime`. UPPER_UNDERSCORE использовать для defines, const и enums. Аббревиатуры и сокращения в именах должны записываться в нижнем регистре.
Допускается использование смешанного стиля в случае использования HAL или при использовании периферии(Пример: HAL_RTC_MspDeInit).
exportHtmlSource(); // НЕЛЬЗЯ: exportHTMLSource();
openDvdPlayer();    // НЕЛЬЗЯ: openDVDPlayer();
RTC_InitCalendar(); // НЕЛЬЗЯ: RTCInitCalendar();

Отступы от края для новой строки (размер Tab'a 4 пробела). Для отступов использовать пробелы. 
Удаляйте пробелы в конце строк, для этого включите в настройках вашей IDE опцию "Remove trailing spaces". 
Скобки открытия функции, цикла, условия располагать друг под другом и указывать всегда, даже если содержит всего одно выражение:

    if (condition1 == true)
    {
        while (loop1 ==  true)
        {
            ...
        }
        result = 1;
    }

Мракобесием считать:

    if (condition1) {
        while (loop1) {
            ...
        }
        result = 1;
    }
    if (condition2) result = 2;

Внешние функции именовать с префиксом, указывающим где описана функция. Обязательно для функций, работающих с аппаратной частью, рекомендуется для всех остальных.

    void RTC_Func(void)
    {
        ...
    }

    void SPI_Func(void)
    {
        ...
    }

Аббревиатуры подчиняются тем же правилам именования что и весь остальной текст.

    // main counter of RTC
    uint64_t rtcCounter = 0;

Нельзя включать в конструкцию for() выражения, не относящиеся к управлению циклом.

sum = 0;                       	   // НЕЛЬЗЯ: for (i = 0, sum = 0; i < 100; i++)
for (i = 0; i < 100; i++)                	   		  { 
  {                                                         sum += value[i];
      sum += value[i];                                }
  }

Переменные, относящиеся к циклу, следует инициализировать непосредственно перед ним.

isDone = false;
while (!isDone)
{
    ...                      
}
 // НЕ РЕКОМЕНДУЕТСЯ:
bool isDone = false;
…
while (!isDone)
{
    …
}

Избегайте сложных уловных выражений. Вместо этого вводите булевы переменные.
bool isFinished = (elementNo < 0) || (elementNo > maxElement);
bool isRepeatedEntry = elementNo == lastElement;
if isFinished || isRepeatedEntry)
{
 :
}
// NOT:
if((elementNo < 0) || (elementNo > maxElement)|| elementNo == lastElement)
{
 : 
}
Задание булевых переменных для выражений приведёт к самодокументированию программы. Конструкцию будет легче читать, отлаживать и поддерживать.


Максимальное значение символов с строке кода не должно превышать 80 символов. При необходимости нужно переносить код на новую строку без ущерба читаемости кода. 
Незавершённость разбитых строк должна быть очевидна.
totalSum = a + b + c + \
		d + e;
function (param1, param2, \
	param3);

Не следует использовать goto.

Этот оператор нарушает принципы структурного программирования. Следует использовать только в очень редких случаях (например, для выхода из глубоко вложенного цикла), когда иные варианты однозначно ухудшат читаемость.
   
Конструкцию switch следует оформлять следующим образом:

switch(condition)
{
	case ABC:
{
	statements;
	//Отсутствует break;
}
case DEF:
{
	statements;
	break;
}
case XYZ:
{
	statements;
	break;
}
default:
{
	statements;
	Break;
}

}
Если где-то отсутствует ключевое слово break, то предупреждением об этом должен служить комментарий. Программисты часто забывают ставить это слово, поэтому случай нарочного его пропуска должен описываться специально.


•	Операторы следует отбивать пробелами.
•	После запятых следует ставить пробелы.
•	После точек с запятой в цикле for следует ставить пробелы.

a = (b + c) * d; // НЕ РЕКОМЕНДУЕТСЯ: a=(b+c)*d

doSomething(a, b, c, d); // НЕ РЕКОМЕНДУЕТСЯ: doSomething(a,b,c,d);
for(i = 0; i < 10; i++)
{
}
// НЕ РЕКОМЕНДУЕТСЯ: for(i=0;i<10;i++)
Выделяет отдельные части выражений. Улучшает читаемость. 




Во всех остальных спорных моментах оформления кода руководствоваться [Linux kernel coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html "Linux kernel coding style")

## Имена файлов

Имена файлов выполнять в CamelCase  `RtcBoard`.

## Название переменных и функций

Следует использовать парные антонимы для методов, выполняющих парные (противоположные) действия: get/set, add/remove, create/destroy, start/stop, insert/delete,increment/decrement, old/new, begin/end, first/last, 
up/down, min/max,next/previous, old/new, open/close, show/hide.

Любая переменная должна иметь понятное название, по которому можно судить о ее предназначении. Бессмысленных и неочевидных переменных стоит избегать. Имя переменной должно характеризовать проблему реального мира, а не ее решение на языке программирования. Проще всего словами проговорить описываемую переменной сущность и назвать переменную соответствующими словами.

Название переменной не должно быть слишком кратким, чтобы вводить в заблуждение людей, но в это же время оно не должно быть и слишком длинным, так как это некрасиво с точки зрения чтения кода. Длина должна быть достаточной, чтобы не нужно было ломать голову. Но информативность названия переменной превалирует над ее компактностью. Если для нормального названия переменной НУЖНО использовать много знаков - используйте.

В именах переменных следует использовать спецификаторы Count и Index вместо Num. Это логично, так как они четко отражают назначение переменной (количество и номер), а вот Num выглядит достаточно двусмысленно и может в некоторых случаях ввести в заблуждение.

Это нормально, когда небольшой цикл из 1-3 строк имеет индекс под названием i, j или k. Но если тело цикла заметно больше, то лучше давать индексам осмысленные имена. И вам будет проще разобраться с таким кодом со временем (сразу же становится понятно, что делает цикл) и другим программистам, которые будут работать с вашим кодом, тоже станет легче.

Давайте более короткие имена переменным с более узкой областью видимости, соответственно, более длинные и подробные имена — переменным с более глобальной (в рамках метода) областью видимости.

Избегайте аббревиатур и неочевидных сокращений. Плохо: cl (call stack), gfx (graphics), dpt (department)

Использовать только согласованные сокращения: только max, не maximum; только num, не no; месяцы первым трем буквам (Jan, Feb, Mar). Полный список будет представлен позже.

Избегать имен с похожими значениями (в рамках конкретной области видимости): fileNumber/fileIndex; scoresNumber/scoresCount. Применять только один из вариантов. Пишите имена без орфографических ошибок и опечаток.

Избегайте именования переменных ничего не значащими (значащими только для вас) именами (snuffi, elizabeth) если только они не являются представляемыми в программе сущностями.

Имена булевых переменных должны быть в утвердительной форме и подразумевать булево значение: done, error, found, finished. Плохо: status, source.
Префикс is следует использовать только для булевых (логических) переменных и методов.
isVisible, isFinished, isFound, isOpen
В некоторых ситуациях префикс is лучше заменить на другой: has, can или should:
bool hasLicense();
bool canEvaluate();
bool shouldSort();
Нельзя давать булевым (логическим) переменным имена, содержащие отрицание.
bool isError; // НЕЛЬЗЯ: isNoError
bool isFound; // НЕЛЬЗЯ: isNotFound

Следует избегать неявного сравнения булевых (логических) переменных и указателей с нулём.

if (nLines != 0)  // НЕ РЕКОМЕНДУЕТСЯ: if (nLines)
if (value != 0.0) // НЕ РЕКОМЕНДУЕТСЯ: if (value)
if(pointer!=nullptr) // НЕ РЕКОМЕНДУЕТСЯ if(pointer)

Не использовать имя переменной temp или Temp. Нужно временное пристанище информации - распиши подробнее: TempSensorValue, tempLastEventTime.

Следует избегать «магических» чисел в коде. Числа, отличные от 0 или 1, следует объявлять как именованные константы.

Если число само по себе не имеет очевидного значения, читаемость улучшается путём введения именованной константы. Другой подход — создание метода, с помощью которого можно было бы осуществлять доступ к константе.
Константы с плавающей точкой следует записывать с десятичной точкой и с указанием по крайней мере одной цифры после запятой.


double total = 0.0;    // НЕ РЕКОМЕНДУЕТСЯ:  double total = 0;
double speed = 3.0e8;  // НЕ РЕКОМЕНДУЕТСЯ:  double speed = 3e8;

double sum = (a + b) * 10.0;

Это подчёркивает различные подходы при работе с целыми числами и числами с плавающей точкой. С точки зрения математики, эти две модели совершенно различны и не совместимы.

Константы с плавающей точкой следует всегда записывать, по крайней мере, с одной цифрой до десятичной точки.

double total = 0.5 	// НЕ РЕКОМЕНДУЕТСЯ: 	double total = .5;

Следует использовать nullptr вместо NULL или 0 при обнулении указателей.

## Комментарии

Комментарии должны располагаться по ходу кода, а не с боку от него. Допускается комментирование с боку от кода при коротких комментариях у объявления переменных в одном месте. Для комментариев настоятельно рекомендуется использовать английский язык, использование русского языка допускается в самом крайнем случае, когда идиоматически выражения на английском сложны в понимании программисту "средней руки". Следует избегать смеси языков в одном файле.

    // Comment
    uint8_t var1 = 0;
    // Comment
    uint8_t var2 = 0;
    ...
    // Comment
    if (var1 < var2)
    {
        ...
    }

допускается:

    uint8_t var1 = 0; // Comment
    uint8_t var2 = 0; // Comment
    uint8_t var3 = 0; // Comment
    uint8_t var4 = 0; // Comment
    uint8_t var5 = 0; // Comment

Перед комментарием должна идти пустая строка, кроме случаев, когда происходит комментирование однотипных действий/параметров/переменных.

Комментарии должны быть к каждой функции перед ее реализацией. Должны описывать кратко или подробно действие функции, входные параметры и возвращаемое значение. Не рекомендуется комментировать что-то в теле функции, кроме объявления локальных переменных. Если возникает потребность в комментариях внутри функции, то лучше инкапсулировать этот код и прокомментировать его как отдельно действие.

    /*!
     * \brief Reads the current GPIO input value
     *
     * \param [IN] obj Pointer to the GPIO object
     * \retval value Current GPIO input value
     */
    uint32_t GpioMcuRead(Gpio_t *obj)
    {
        ...
    }

Комментируйте окончание `#endif // __SOME_FILE_H__`

В заголовочных файлах объединяйте код по действиям и разделяйте его на соответствующие части. В документе последовательно описывать следующие части:

-  Хедеры
-  Макросы, прочие дефайны
-  struct и enum
-  Прототипы функций
-  Переменные
-  Статик функции
-  Экспортируемые функции

Пример файла:

    #ifndef __RTC_BOARD_H__
    #define __RTC_BOARD_H__

    #include "em_device.h"
    #include "em_rtc.h"
    #include "em_cmu.h"
    #include "condition.h"
    #include "RotSensor-board.h"

    #define WAKE_AFTER_INT SCB->SCR &= ~SCB_SCR_SLEEPONEXIT_Msk
    #define SLEEP_AFTER_INT SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk

    //#define PULSE_OUT_WAIT  	0x04
    //#define OPTO_TRANSMIT_PACKET	0x05

    void RtcSetup(void);
    void RtcSetImmediatelyMeas(void);
    void RtcFastSpeedMeasSet(void);
    void RtcNormalSpeedMeasSet(void);
    uint8_t RtcEveryHourFlagGet(void);
    void RtcEveryHourFlagClear(void);

	#endif /* __RTC_BOARD_H__ */

## TODO

Комментарии типа TODO должны оставляться в местах проявления недоделки или в месте потенциального добавления/исправления. Также допускается оставлять комментарии типа TODO в заголовке файла, если необходимо провести работы со всем файлом или его значительной частью. Описание действия должны быть исчерпывающими, чтобы любой сторонний разработчик понял что требуется сделать с минимальными знаниями о проекте.

    /// \todo Write a test verifying the intersection of the output parameter - the address in the EEPROM - depending on different input data.

или

    /*! \todo Realize the same for the heat meter as for the water above */

заголовок файла

    /*!
     * \file ...
     * ...
     * \author ...
     *
     * \todo Total file code refactoring
     */


Логические блоки в коде следует отделять пустой строкой.

Matrix4x4 matrix = new Matrix4x4();

double cosAngle = Math.cos(angle);
double sinAngle = Math.sin(angle);

matrix.setElement(1, 1, cosAngle);
matrix.setElement(1, 2, sinAngle);
matrix.setElement(2, 1, -sinAngle);
matrix.setElement(2, 2, cosAngle);

multiply(matrix);

Улучшает читаемость.

